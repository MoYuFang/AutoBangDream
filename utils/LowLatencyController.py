"""Generated by deepseek-r1v3"""

import socket
import time
import subprocess

class LowLatencyController:
  def __init__(self, adb_path="adb", device="127.0.0.1:7555", local_port=12345):
    self.adb_path = adb_path
    self.device = device
    self.local_port = local_port
    self.remote_port = 12345
    self.socket = None
    self.latency_stats = []
      
  def setup_adb_forward(self):
    try:
      # 移除可能存在的旧转发
      remove_cmd = [self.adb_path, "-s", self.device, "forward", "--remove", f"tcp:{self.local_port}"]
      subprocess.run(remove_cmd, capture_output=True)
      
      # 设置新的端口转发
      forward_cmd = [self.adb_path, "-s", self.device, "forward", f"tcp:{self.local_port}", f"tcp:{self.remote_port}"]
      result = subprocess.run(forward_cmd, capture_output=True, text=True, check=True)
      print(f"ADB forward established: {result.stdout.strip()}")
      
      # 等待转发稳定
      time.sleep(0.5)
      return True
    except subprocess.CalledProcessError as e:
      print(f"ADB forward failed: {e}")
      return False
  
  def connect_with_retry(self, max_retries=3):
    for attempt in range(max_retries):
      try:
        self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        # 设置socket选项以减少延迟
        self.socket.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)  # 禁用Nagle算法
        self.socket.settimeout(5.0)
        self.socket.connect(('127.0.0.1', self.local_port))
        print("Connected to BangCheater")
        return True
      except Exception as e:
        print(f"Connection attempt {attempt + 1} failed: {e}")
        if self.socket:
            self.socket.close()
            self.socket = None
        time.sleep(0.1 * (attempt + 1))  # 递增重试延迟
    return False
  
  def send_command_low_latency(self, command, expect_response=True):
    if not self.socket: return None
        
    start_time = time.time()
    
    try:
      if not command.endswith('\n'): command += '\n'
      
      # 发送命令
      self.socket.sendall(command.encode('utf-8'))
      send_time = time.time()
      
      if not expect_response: return "OK"
          
    except socket.timeout:
      print(f"Command timeout: {command.strip()}")
      return None
    except Exception as e:
      print(f"Command failed: {e}")
      return None
  def recv(self):
    # 接收响应（带超时）
    response = self.socket.recv(1024).decode('utf-8').strip()
    return response
  
  def start_bangcheater(
    self,
    remote_path="/data/local/tmp/bangcheater",
    commands_path="./data/local/tmp/commands.sheet"
  ):
      try:
        print("Kill bangcheater")
        kill_cmd = [self.adb_path, "-s", self.device, "shell", "pkill", "-f", "bangcheater"]
        subprocess.run(kill_cmd, capture_output=True)

        print("Start bangcheater")
        start_cmd = [self.adb_path, "-s", self.device, "shell", f"{remote_path}", f"{commands_path}", "-t"]
        self.p = subprocess.Popen(start_cmd, stdin=subprocess.PIPE, stdout=subprocess.DEVNULL)
        
        print("BangCheater started")
        time.sleep(1)  # 等待服务启动
        return True
          
      except subprocess.CalledProcessError as e:
        print(f"Failed to start BangCheater: {e}")
        return False
  def run_commands_from_file(self, file_path:str|list):
      if isinstance(file_path, str):
          with open(file_path, 'r') as f:
              commands = [line.strip() for line in f if line.strip() and not line.startswith('#')]
      else:
          commands = file_path
      try:
        results = []
        for cmd in commands:
          start_time = time.time()
          response = self.send_command_low_latency(cmd)
          end_time = time.time()
          
          if response:
            latency = (end_time - start_time) * 1000
            results.append(f"{cmd} -> {response} ({latency:.1f}ms)")
            print(f"Executed: {cmd} -> {response} ({latency:.1f}ms)")
          else:
            results.append(f"{cmd} -> FAILED")
            print(f"Failed: {cmd}")
          
          time.sleep(0.01)  # 小延迟避免过载
        
        return results
          
      except Exception as e:
        print(f"Error running commands: {e}")
        return []
  def cleanup(self):
    if self.socket:
      try: self.send_command_low_latency("QUIT", expect_response=False)
      except: pass
      self.socket.close()
      
    # 移除ADB转发
    try:
      remove_cmd = [self.adb_path, "-s", self.device, "forward", "--remove", f"tcp:{self.local_port}"]
      subprocess.run(remove_cmd, capture_output=True)
    except: pass
    
if __name__ == "__main__":
  clr = LowLatencyController(
    adb_path="adb",
    device="127.0.0.1:7555",
    local_port=12345
  )
  try:
    # 1. 设置ADB转发
    if not clr.setup_adb_forward(): exit(1)
    
    # 2. 启动bangcheater
    clr.start_bangcheater()
    
    # 3. 连接
    if not clr.connect_with_retry():
      print("Failed to connect after retries")
      exit(1)

    print("file")
    clr.send_command_low_latency("f\n")
    
    time.sleep(1.0)
    
    print("file")
    clr.send_command_low_latency("f\n")
    
    while True:pass
      
  finally:
    clr.cleanup()